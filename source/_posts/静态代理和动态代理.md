---
title: 静态代理和动态代理
date: 2017-01-20 18:32:28
tags:
---

### 需求
获取数据的时候显示一个动画，数据回来后，显示数据

### 问题
动画还没显示，数据就回来了，需要做个判断，在数据回来的时候，如果时间太短，则延迟一下再显示

### 解决办法
对callback里所有方法包装一下，加入时间判断功能。不在原来的callback实现里直接修改是符合开闭原则的。

<!--more-->

### 静态代理

```java
public class DelayPullDownCallbackWrapper implements NewsDataLoader.PullDownCallback,
        Handler.Callback {
    public static final int MIN_PULL_TIME = 1000;
    private  static final int ARG_TRUE = 1;
    private static final int MSG_ONLOADDATA = 1;
    private static final int MSG_ONLOADNODATA = 2;
    private static final int MSG_ONLOADFAILED = 3;

    private NewsDataLoader.PullDownCallback pullDownCallback;
    private long startPullDown;
    private Handler handler;

    public DelayPullDownCallbackWrapper(NewsDataLoader.PullDownCallback pullDownCallback) {
        this.pullDownCallback = pullDownCallback;
        handler = new Handler(this);
    }

    @Override
    public void onLoadData(int newDataCount, boolean continuityStreamId) {
        long delayTime = getDelayTime();
        if (delayTime <= 0) {
            pullDownCallback.onLoadData(newDataCount, continuityStreamId);
        } else {
            Message msg = Message.obtain();
            msg.arg1 = newDataCount;
            msg.arg2 = continuityStreamId ? ARG_TRUE : 0;
            msg.what = MSG_ONLOADDATA;
            handler.sendMessageDelayed(msg, delayTime);
        }
    }

    private long getDelayTime() {
        long passTime = SystemClock.elapsedRealtime() - startPullDown;
        return MIN_PULL_TIME - passTime;
    }

    public void updatePullDownTime() {
        startPullDown = SystemClock.elapsedRealtime();
    }


    @Override
    public void onLoadNodata() {
        long delayTime = getDelayTime();
        if (delayTime <= 0) {
            pullDownCallback.onLoadNodata();
        } else {
            handler.sendEmptyMessageDelayed(MSG_ONLOADNODATA, delayTime);
        }
    }

    @Override
    public void onLoadFailed(boolean optTooFast) {
        long delayTime = getDelayTime();
        if (delayTime <= 0) {
            pullDownCallback.onLoadFailed(optTooFast);
        } else {
            Message msg = Message.obtain();
            msg.arg1 = optTooFast ? ARG_TRUE : 0;
            msg.what = MSG_ONLOADFAILED;
            handler.sendMessageDelayed(msg, delayTime);
        }
    }

    @Override
    public boolean handleMessage(Message msg) {
        switch (msg.what) {
            case MSG_ONLOADDATA:
                int newDataCount = msg.arg1;
                boolean continuityStreamId = msg.arg2 == ARG_TRUE;
                pullDownCallback.onLoadData(newDataCount, continuityStreamId);
                break;
            case MSG_ONLOADNODATA:
                pullDownCallback.onLoadNodata();
                break;
            case MSG_ONLOADFAILED:
                pullDownCallback.onLoadFailed(msg.arg1 == ARG_TRUE);
                break;
        }
        return true;
    }
}

```

功能是实现了，但是有这几个缺点

- callback里没多一个方法，代理都写相应实现。实现容易出错
- 这套代理的逻辑，对于其它callback不能重用


### 动态代理

```java
public class DelayLoadCallbackImpl<T> implements InvocationHandler, Handler.Callback {
    private static final int MSG_CALL_METHOD = 1;

    public static DelayLoadCallbackImpl<SubManager.LoadCallback> wrap(SubManager.LoadCallback callback) {
        return new DelayLoadCallbackImpl<SubManager.LoadCallback>(callback);
    }


    private T subject;
    private long startPullDown;
    private Handler handler;
    private T delayImpl;

    public DelayLoadCallbackImpl(T subject) {
        this.subject = subject;
        handler = new Handler(this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long delayTime = getDelayTime();
        if (delayTime <= 0) {
            return method.invoke(subject, args);
        } else {
            Message msg = Message.obtain();
            msg.obj = new MethodBean(args, method);
            msg.what = MSG_CALL_METHOD;
            handler.sendMessageDelayed(msg, delayTime);
        }
        return null;
    }

    @Override
    public boolean handleMessage(Message msg) {
        switch (msg.what) {
            case MSG_CALL_METHOD:
                MethodBean bean = (MethodBean) msg.obj;
                try {
                    bean.method.invoke(subject, bean.args);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
        }
        return true;
    }

    static class MethodBean {
        Method method;
        Object[] args;

        public MethodBean(Object[] args, Method method) {
            this.args = args;
            this.method = method;
        }
    }

    private long getDelayTime() {
        long passTime = SystemClock.elapsedRealtime() - startPullDown;
        return MIN_PULL_TIME - passTime;
    }

    public void updatePullDownTime() {
        startPullDown = SystemClock.elapsedRealtime();
    }


    public T getDelayImpl() {
        if (delayImpl == null) {
            delayImpl = (T) Proxy.newProxyInstance(this.getClass().getClassLoader(),
                    subject.getClass().getInterfaces(), this);
        }
        return delayImpl;
    }
}

```

- 一个实现，所有callback接口都能用
- callback增加方法，代理类不需要修改